/**
 * @fileoverview Comprehensive question bank for the ClawOS Elicitation Engine.
 *
 * Contains 80+ structured questions organized by category:
 *   - Common questions (asked for every framework)
 *   - Domain-specific questions (8 domains, 8-12 each)
 *   - Architecture questions
 *   - Integration questions
 *   - Deployment questions
 *   - Claude Code integration questions
 *
 * Each question conforms to the QuestionDefinition schema and supports
 * conditional display, smart defaults, and answer transformation.
 *
 * @module question-bank
 * @version 1.0.0
 * @author Victor De Marco
 */

// ---------------------------------------------------------------------------
// Question Definition JSDoc
// ---------------------------------------------------------------------------

/**
 * @typedef {'choice' | 'multi-choice' | 'text' | 'confirm' | 'scale'} QuestionType
 */

/**
 * @typedef {'required' | 'recommended' | 'optional'} QuestionPriority
 */

/**
 * @typedef {Object} QuestionDefinition
 * @property {string}            id        - Unique identifier (category.name format).
 * @property {string}            text      - The question text shown to the user.
 * @property {QuestionType}      type      - Input type expected from the user.
 * @property {string[]}          [options] - Allowed values for choice / multi-choice.
 * @property {*}                 default   - Fallback value when the user skips.
 * @property {QuestionPriority}  priority  - How critical the question is.
 * @property {function(Object): boolean} condition - Returns true when the question
 *           should be presented. Receives the current partial RequirementsProfile.
 * @property {function(*): *}    transform - Post-processes the raw answer into
 *           the value stored in the RequirementsProfile.
 */

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

/** Always returns true -- used for unconditional questions. */
const always = () => true;

/** Returns the answer unchanged. */
const identity = (v) => v;

/** Trims whitespace from text answers. */
const trim = (v) => (typeof v === 'string' ? v.trim() : v);

/** Converts a comma-separated string into an array. */
const csvToArray = (v) => {
  if (Array.isArray(v)) return v;
  if (typeof v !== 'string') return [];
  return v.split(',').map((s) => s.trim()).filter(Boolean);
};

/** Converts a yes/true/1 string into a boolean. */
const toBool = (v) => {
  if (typeof v === 'boolean') return v;
  if (typeof v === 'string') return ['yes', 'true', '1', 'y'].includes(v.toLowerCase());
  return Boolean(v);
};

/** Clamps a numeric scale value between 1 and 10. */
const clampScale = (v) => {
  const n = Number(v);
  if (Number.isNaN(n)) return 5;
  return Math.max(1, Math.min(10, Math.round(n)));
};

// ---------------------------------------------------------------------------
// 1. Common Questions  (asked for ALL frameworks)
// ---------------------------------------------------------------------------

/** @type {QuestionDefinition[]} */
const commonQuestions = [
  {
    id: 'common.name',
    text: 'What would you like to name your framework?',
    type: 'text',
    options: [],
    default: 'my-framework',
    priority: 'required',
    condition: always,
    transform: (v) => trim(v).toLowerCase().replace(/\s+/g, '-'),
  },
  {
    id: 'common.description',
    text: 'Provide a short description of what this framework will do.',
    type: 'text',
    options: [],
    default: 'A custom framework generated by ClawOS.',
    priority: 'required',
    condition: always,
    transform: trim,
  },
  {
    id: 'common.language',
    text: 'Which primary language should the framework use?',
    type: 'choice',
    options: ['javascript', 'typescript'],
    default: 'typescript',
    priority: 'required',
    condition: always,
    transform: (v) => (typeof v === 'string' ? v.toLowerCase() : 'typescript'),
  },
  {
    id: 'common.scale',
    text: 'What scale is this framework intended for?',
    type: 'choice',
    options: ['small', 'medium', 'large'],
    default: 'medium',
    priority: 'required',
    condition: always,
    transform: (v) => {
      const valid = ['small', 'medium', 'large'];
      const normalized = typeof v === 'string' ? v.toLowerCase() : '';
      return valid.includes(normalized) ? normalized : 'medium';
    },
  },
  {
    id: 'common.license',
    text: 'Which license should the framework ship with?',
    type: 'choice',
    options: ['MIT', 'Apache-2.0', 'ISC', 'GPL-3.0', 'BSD-3-Clause', 'none'],
    default: 'MIT',
    priority: 'recommended',
    condition: always,
    transform: identity,
  },
  {
    id: 'common.node_version',
    text: 'Minimum Node.js version to support?',
    type: 'choice',
    options: ['18', '20', '22'],
    default: '18',
    priority: 'recommended',
    condition: always,
    transform: (v) => String(v),
  },
  {
    id: 'common.package_manager',
    text: 'Preferred package manager?',
    type: 'choice',
    options: ['npm', 'pnpm', 'yarn', 'bun'],
    default: 'npm',
    priority: 'optional',
    condition: always,
    transform: (v) => (typeof v === 'string' ? v.toLowerCase() : 'npm'),
  },
  {
    id: 'common.monorepo',
    text: 'Will this framework live inside a monorepo?',
    type: 'confirm',
    options: [],
    default: false,
    priority: 'optional',
    condition: always,
    transform: toBool,
  },
];

// ---------------------------------------------------------------------------
// 2. Architecture Questions
// ---------------------------------------------------------------------------

/** @type {QuestionDefinition[]} */
const architectureQuestions = [
  {
    id: 'arch.pattern',
    text: 'Which architecture pattern best fits your framework?',
    type: 'choice',
    options: ['microservice', 'monolith', 'event-driven', 'pipeline', 'modular'],
    default: 'modular',
    priority: 'required',
    condition: always,
    transform: identity,
  },
  {
    id: 'arch.style',
    text: 'Which code organisation style do you prefer?',
    type: 'choice',
    options: ['layered', 'hexagonal', 'clean', 'feature-based', 'flat'],
    default: 'layered',
    priority: 'required',
    condition: always,
    transform: identity,
  },
  {
    id: 'arch.layers',
    text: 'Which layers should the framework include?',
    type: 'multi-choice',
    options: [
      'presentation',
      'application',
      'domain',
      'infrastructure',
      'persistence',
      'transport',
    ],
    default: ['application', 'domain', 'infrastructure'],
    priority: 'recommended',
    condition: always,
    transform: csvToArray,
  },
  {
    id: 'arch.plugin_system',
    text: 'Should the framework include a plugin / extension system?',
    type: 'confirm',
    options: [],
    default: true,
    priority: 'recommended',
    condition: always,
    transform: toBool,
  },
  {
    id: 'arch.error_handling',
    text: 'Which error-handling strategy should be used?',
    type: 'choice',
    options: ['exceptions', 'result-type', 'error-codes', 'hybrid'],
    default: 'hybrid',
    priority: 'recommended',
    condition: always,
    transform: identity,
  },
  {
    id: 'arch.logging',
    text: 'Include a structured logging layer?',
    type: 'confirm',
    options: [],
    default: true,
    priority: 'recommended',
    condition: always,
    transform: toBool,
  },
  {
    id: 'arch.config_format',
    text: 'Preferred configuration file format?',
    type: 'choice',
    options: ['json', 'yaml', 'toml', 'env', 'js'],
    default: 'yaml',
    priority: 'optional',
    condition: always,
    transform: identity,
  },
  {
    id: 'arch.event_system',
    text: 'Should the framework have a built-in event / pub-sub system?',
    type: 'confirm',
    options: [],
    default: false,
    priority: 'optional',
    condition: (profile) => profile?.architecture?.pattern !== 'event-driven',
    transform: toBool,
  },
];

// ---------------------------------------------------------------------------
// 3. Domain-Specific Questions
// ---------------------------------------------------------------------------

// ---- 3a. API Domain ----

/** @type {QuestionDefinition[]} */
const apiQuestions = [
  {
    id: 'api.protocol',
    text: 'Which API protocol(s) should the framework support?',
    type: 'multi-choice',
    options: ['REST', 'GraphQL', 'gRPC', 'WebSocket', 'tRPC'],
    default: ['REST'],
    priority: 'required',
    condition: (p) => p?.domain === 'api',
    transform: csvToArray,
  },
  {
    id: 'api.auth',
    text: 'Which authentication mechanisms should be built in?',
    type: 'multi-choice',
    options: ['JWT', 'OAuth2', 'API-Key', 'Session', 'Basic', 'none'],
    default: ['JWT'],
    priority: 'required',
    condition: (p) => p?.domain === 'api',
    transform: csvToArray,
  },
  {
    id: 'api.validation',
    text: 'Include request validation / schema enforcement?',
    type: 'confirm',
    options: [],
    default: true,
    priority: 'required',
    condition: (p) => p?.domain === 'api',
    transform: toBool,
  },
  {
    id: 'api.rate_limiting',
    text: 'Should built-in rate-limiting be included?',
    type: 'confirm',
    options: [],
    default: true,
    priority: 'recommended',
    condition: (p) => p?.domain === 'api',
    transform: toBool,
  },
  {
    id: 'api.docs',
    text: 'Should the framework auto-generate API documentation (OpenAPI / Swagger)?',
    type: 'confirm',
    options: [],
    default: true,
    priority: 'recommended',
    condition: (p) => p?.domain === 'api',
    transform: toBool,
  },
  {
    id: 'api.versioning',
    text: 'Which API versioning strategy should be used?',
    type: 'choice',
    options: ['url-prefix', 'header', 'query-param', 'none'],
    default: 'url-prefix',
    priority: 'recommended',
    condition: (p) => p?.domain === 'api',
    transform: identity,
  },
  {
    id: 'api.cors',
    text: 'Should CORS handling be built in?',
    type: 'confirm',
    options: [],
    default: true,
    priority: 'recommended',
    condition: (p) => p?.domain === 'api',
    transform: toBool,
  },
  {
    id: 'api.database',
    text: 'Which database layer should be integrated?',
    type: 'choice',
    options: ['postgres', 'mysql', 'mongodb', 'sqlite', 'none'],
    default: 'postgres',
    priority: 'recommended',
    condition: (p) => p?.domain === 'api',
    transform: identity,
  },
  {
    id: 'api.caching',
    text: 'Include a caching layer (e.g. Redis adapter)?',
    type: 'confirm',
    options: [],
    default: false,
    priority: 'optional',
    condition: (p) => p?.domain === 'api',
    transform: toBool,
  },
  {
    id: 'api.middleware_pipeline',
    text: 'Should the framework expose a middleware pipeline (like Express / Koa)?',
    type: 'confirm',
    options: [],
    default: true,
    priority: 'recommended',
    condition: (p) => p?.domain === 'api',
    transform: toBool,
  },
];

// ---- 3b. CLI Domain ----

/** @type {QuestionDefinition[]} */
const cliQuestions = [
  {
    id: 'cli.style',
    text: 'Which CLI interaction style should the framework support?',
    type: 'choice',
    options: ['command-based', 'interactive-prompts', 'hybrid'],
    default: 'hybrid',
    priority: 'required',
    condition: (p) => p?.domain === 'cli',
    transform: identity,
  },
  {
    id: 'cli.arg_parsing',
    text: 'Should the framework include its own argument parser?',
    type: 'confirm',
    options: [],
    default: true,
    priority: 'required',
    condition: (p) => p?.domain === 'cli',
    transform: toBool,
  },
  {
    id: 'cli.subcommands',
    text: 'Will the CLI need nested sub-commands (like git)?',
    type: 'confirm',
    options: [],
    default: true,
    priority: 'required',
    condition: (p) => p?.domain === 'cli',
    transform: toBool,
  },
  {
    id: 'cli.output_formats',
    text: 'Which output formats should be supported?',
    type: 'multi-choice',
    options: ['plain-text', 'json', 'table', 'yaml', 'colored'],
    default: ['plain-text', 'json', 'colored'],
    priority: 'recommended',
    condition: (p) => p?.domain === 'cli',
    transform: csvToArray,
  },
  {
    id: 'cli.config_file',
    text: 'Should the CLI support a user configuration file (e.g. ~/.myrc)?',
    type: 'confirm',
    options: [],
    default: true,
    priority: 'recommended',
    condition: (p) => p?.domain === 'cli',
    transform: toBool,
  },
  {
    id: 'cli.auto_complete',
    text: 'Include shell auto-completion generation (bash/zsh/fish)?',
    type: 'confirm',
    options: [],
    default: true,
    priority: 'recommended',
    condition: (p) => p?.domain === 'cli',
    transform: toBool,
  },
  {
    id: 'cli.progress_indicators',
    text: 'Should the framework provide spinners / progress bars?',
    type: 'confirm',
    options: [],
    default: true,
    priority: 'recommended',
    condition: (p) => p?.domain === 'cli',
    transform: toBool,
  },
  {
    id: 'cli.help_generation',
    text: 'Auto-generate --help text from command metadata?',
    type: 'confirm',
    options: [],
    default: true,
    priority: 'recommended',
    condition: (p) => p?.domain === 'cli',
    transform: toBool,
  },
  {
    id: 'cli.plugin_commands',
    text: 'Allow third-party plugins to register new commands?',
    type: 'confirm',
    options: [],
    default: false,
    priority: 'optional',
    condition: (p) => p?.domain === 'cli',
    transform: toBool,
  },
  {
    id: 'cli.update_notifier',
    text: 'Include a built-in update notifier for new versions?',
    type: 'confirm',
    options: [],
    default: false,
    priority: 'optional',
    condition: (p) => p?.domain === 'cli',
    transform: toBool,
  },
];

// ---- 3c. Testing Domain ----

/** @type {QuestionDefinition[]} */
const testingQuestions = [
  {
    id: 'testing.runner',
    text: 'Which test-runner paradigm should the framework follow?',
    type: 'choice',
    options: ['bdd', 'tdd', 'spec', 'tap'],
    default: 'bdd',
    priority: 'required',
    condition: (p) => p?.domain === 'testing',
    transform: identity,
  },
  {
    id: 'testing.assertion_style',
    text: 'Preferred assertion style?',
    type: 'choice',
    options: ['expect', 'assert', 'should', 'chai-compatible'],
    default: 'expect',
    priority: 'required',
    condition: (p) => p?.domain === 'testing',
    transform: identity,
  },
  {
    id: 'testing.mocking',
    text: 'Should the framework include a built-in mocking / stubbing library?',
    type: 'confirm',
    options: [],
    default: true,
    priority: 'required',
    condition: (p) => p?.domain === 'testing',
    transform: toBool,
  },
  {
    id: 'testing.coverage',
    text: 'Include code-coverage instrumentation?',
    type: 'confirm',
    options: [],
    default: true,
    priority: 'recommended',
    condition: (p) => p?.domain === 'testing',
    transform: toBool,
  },
  {
    id: 'testing.snapshot',
    text: 'Support snapshot testing?',
    type: 'confirm',
    options: [],
    default: true,
    priority: 'recommended',
    condition: (p) => p?.domain === 'testing',
    transform: toBool,
  },
  {
    id: 'testing.parallel',
    text: 'Run tests in parallel by default?',
    type: 'confirm',
    options: [],
    default: true,
    priority: 'recommended',
    condition: (p) => p?.domain === 'testing',
    transform: toBool,
  },
  {
    id: 'testing.watch_mode',
    text: 'Include a file-watch mode for re-running tests on change?',
    type: 'confirm',
    options: [],
    default: true,
    priority: 'recommended',
    condition: (p) => p?.domain === 'testing',
    transform: toBool,
  },
  {
    id: 'testing.reporters',
    text: 'Which test reporters should be included?',
    type: 'multi-choice',
    options: ['console', 'json', 'junit', 'html', 'tap'],
    default: ['console', 'json'],
    priority: 'recommended',
    condition: (p) => p?.domain === 'testing',
    transform: csvToArray,
  },
  {
    id: 'testing.fixtures',
    text: 'Include a test-fixture / factory system?',
    type: 'confirm',
    options: [],
    default: true,
    priority: 'optional',
    condition: (p) => p?.domain === 'testing',
    transform: toBool,
  },
  {
    id: 'testing.browser',
    text: 'Should the framework support browser-based / E2E test execution?',
    type: 'confirm',
    options: [],
    default: false,
    priority: 'optional',
    condition: (p) => p?.domain === 'testing',
    transform: toBool,
  },
];

// ---- 3d. UI Domain ----

/** @type {QuestionDefinition[]} */
const uiQuestions = [
  {
    id: 'ui.rendering',
    text: 'Which rendering strategy should the framework use?',
    type: 'choice',
    options: ['virtual-dom', 'incremental-dom', 'compiled', 'signals', 'server-components'],
    default: 'virtual-dom',
    priority: 'required',
    condition: (p) => p?.domain === 'ui',
    transform: identity,
  },
  {
    id: 'ui.component_model',
    text: 'Preferred component model?',
    type: 'choice',
    options: ['class-based', 'functional', 'web-components', 'hybrid'],
    default: 'functional',
    priority: 'required',
    condition: (p) => p?.domain === 'ui',
    transform: identity,
  },
  {
    id: 'ui.state_management',
    text: 'Built-in state management approach?',
    type: 'choice',
    options: ['built-in-store', 'signals', 'atoms', 'context-only', 'none'],
    default: 'built-in-store',
    priority: 'required',
    condition: (p) => p?.domain === 'ui',
    transform: identity,
  },
  {
    id: 'ui.styling',
    text: 'Which styling solution should be included?',
    type: 'choice',
    options: ['css-modules', 'css-in-js', 'utility-classes', 'scoped-css', 'none'],
    default: 'css-modules',
    priority: 'recommended',
    condition: (p) => p?.domain === 'ui',
    transform: identity,
  },
  {
    id: 'ui.ssr',
    text: 'Should server-side rendering (SSR) be supported?',
    type: 'confirm',
    options: [],
    default: false,
    priority: 'recommended',
    condition: (p) => p?.domain === 'ui',
    transform: toBool,
  },
  {
    id: 'ui.routing',
    text: 'Include a client-side router?',
    type: 'confirm',
    options: [],
    default: true,
    priority: 'recommended',
    condition: (p) => p?.domain === 'ui',
    transform: toBool,
  },
  {
    id: 'ui.accessibility',
    text: 'Include built-in accessibility (a11y) helpers and checks?',
    type: 'confirm',
    options: [],
    default: true,
    priority: 'recommended',
    condition: (p) => p?.domain === 'ui',
    transform: toBool,
  },
  {
    id: 'ui.animations',
    text: 'Include an animation / transition system?',
    type: 'confirm',
    options: [],
    default: false,
    priority: 'optional',
    condition: (p) => p?.domain === 'ui',
    transform: toBool,
  },
  {
    id: 'ui.dev_tools',
    text: 'Ship with developer tools (component inspector, state debugger)?',
    type: 'confirm',
    options: [],
    default: true,
    priority: 'recommended',
    condition: (p) => p?.domain === 'ui',
    transform: toBool,
  },
  {
    id: 'ui.i18n',
    text: 'Include internationalisation (i18n) support?',
    type: 'confirm',
    options: [],
    default: false,
    priority: 'optional',
    condition: (p) => p?.domain === 'ui',
    transform: toBool,
  },
];

// ---- 3e. Data Domain ----

/** @type {QuestionDefinition[]} */
const dataQuestions = [
  {
    id: 'data.type',
    text: 'What kind of data processing does the framework target?',
    type: 'choice',
    options: ['etl', 'stream-processing', 'batch', 'real-time', 'hybrid'],
    default: 'etl',
    priority: 'required',
    condition: (p) => p?.domain === 'data',
    transform: identity,
  },
  {
    id: 'data.sources',
    text: 'Which data sources should be supported out of the box?',
    type: 'multi-choice',
    options: ['databases', 'files', 'apis', 'queues', 'streams', 'websockets'],
    default: ['databases', 'files', 'apis'],
    priority: 'required',
    condition: (p) => p?.domain === 'data',
    transform: csvToArray,
  },
  {
    id: 'data.formats',
    text: 'Which data formats should be supported?',
    type: 'multi-choice',
    options: ['json', 'csv', 'xml', 'parquet', 'avro', 'protobuf', 'yaml'],
    default: ['json', 'csv'],
    priority: 'required',
    condition: (p) => p?.domain === 'data',
    transform: csvToArray,
  },
  {
    id: 'data.validation',
    text: 'Include data validation / schema enforcement?',
    type: 'confirm',
    options: [],
    default: true,
    priority: 'required',
    condition: (p) => p?.domain === 'data',
    transform: toBool,
  },
  {
    id: 'data.transformations',
    text: 'Should the framework provide a declarative transformation DSL?',
    type: 'confirm',
    options: [],
    default: true,
    priority: 'recommended',
    condition: (p) => p?.domain === 'data',
    transform: toBool,
  },
  {
    id: 'data.scheduling',
    text: 'Include job scheduling (cron-style)?',
    type: 'confirm',
    options: [],
    default: false,
    priority: 'recommended',
    condition: (p) => p?.domain === 'data',
    transform: toBool,
  },
  {
    id: 'data.retry_strategy',
    text: 'Include built-in retry / dead-letter strategies for failed processing?',
    type: 'confirm',
    options: [],
    default: true,
    priority: 'recommended',
    condition: (p) => p?.domain === 'data',
    transform: toBool,
  },
  {
    id: 'data.monitoring',
    text: 'Include pipeline monitoring / metrics?',
    type: 'confirm',
    options: [],
    default: true,
    priority: 'recommended',
    condition: (p) => p?.domain === 'data',
    transform: toBool,
  },
  {
    id: 'data.backpressure',
    text: 'Should the framework handle back-pressure automatically?',
    type: 'confirm',
    options: [],
    default: true,
    priority: 'optional',
    condition: (p) => p?.domain === 'data' && p?.scalability !== 'small',
    transform: toBool,
  },
  {
    id: 'data.partitioning',
    text: 'Include data partitioning / sharding utilities?',
    type: 'confirm',
    options: [],
    default: false,
    priority: 'optional',
    condition: (p) => p?.domain === 'data' && p?.scalability === 'large',
    transform: toBool,
  },
];

// ---- 3f. AI-Agent Domain ----

/** @type {QuestionDefinition[]} */
const aiAgentQuestions = [
  {
    id: 'ai.agent_type',
    text: 'What kind of AI agent framework is this?',
    type: 'choice',
    options: ['single-agent', 'multi-agent', 'orchestrator', 'tool-framework', 'hybrid'],
    default: 'single-agent',
    priority: 'required',
    condition: (p) => p?.domain === 'ai-agent',
    transform: identity,
  },
  {
    id: 'ai.llm_providers',
    text: 'Which LLM providers should be supported?',
    type: 'multi-choice',
    options: ['openai', 'anthropic', 'google', 'local-llm', 'custom'],
    default: ['anthropic', 'openai'],
    priority: 'required',
    condition: (p) => p?.domain === 'ai-agent',
    transform: csvToArray,
  },
  {
    id: 'ai.tool_use',
    text: 'Should the framework support tool / function calling?',
    type: 'confirm',
    options: [],
    default: true,
    priority: 'required',
    condition: (p) => p?.domain === 'ai-agent',
    transform: toBool,
  },
  {
    id: 'ai.memory',
    text: 'Which memory system should be included?',
    type: 'choice',
    options: ['short-term', 'long-term', 'vector-store', 'hybrid', 'none'],
    default: 'hybrid',
    priority: 'required',
    condition: (p) => p?.domain === 'ai-agent',
    transform: identity,
  },
  {
    id: 'ai.planning',
    text: 'Include a planning / reasoning layer (e.g. chain-of-thought, ReAct)?',
    type: 'confirm',
    options: [],
    default: true,
    priority: 'recommended',
    condition: (p) => p?.domain === 'ai-agent',
    transform: toBool,
  },
  {
    id: 'ai.streaming',
    text: 'Support streaming responses from LLMs?',
    type: 'confirm',
    options: [],
    default: true,
    priority: 'recommended',
    condition: (p) => p?.domain === 'ai-agent',
    transform: toBool,
  },
  {
    id: 'ai.guardrails',
    text: 'Include safety guardrails / output validation?',
    type: 'confirm',
    options: [],
    default: true,
    priority: 'recommended',
    condition: (p) => p?.domain === 'ai-agent',
    transform: toBool,
  },
  {
    id: 'ai.agent_communication',
    text: 'How should agents communicate with each other?',
    type: 'choice',
    options: ['message-passing', 'shared-state', 'event-bus', 'blackboard', 'none'],
    default: 'message-passing',
    priority: 'recommended',
    condition: (p) => {
      if (p?.domain !== 'ai-agent') return false;
      const t = p?.domainSpecific?.ai?.agent_type;
      return t === 'multi-agent' || t === 'orchestrator' || t === 'hybrid';
    },
    transform: identity,
  },
  {
    id: 'ai.observability',
    text: 'Include agent observability (trace logging, decision audit)?',
    type: 'confirm',
    options: [],
    default: true,
    priority: 'recommended',
    condition: (p) => p?.domain === 'ai-agent',
    transform: toBool,
  },
  {
    id: 'ai.human_in_loop',
    text: 'Support human-in-the-loop interaction patterns?',
    type: 'confirm',
    options: [],
    default: false,
    priority: 'optional',
    condition: (p) => p?.domain === 'ai-agent',
    transform: toBool,
  },
];

// ---- 3g. Automation Domain ----

/** @type {QuestionDefinition[]} */
const automationQuestions = [
  {
    id: 'auto.type',
    text: 'What type of automation does this framework target?',
    type: 'choice',
    options: ['task-runner', 'workflow-engine', 'ci-cd', 'scheduler', 'hybrid'],
    default: 'workflow-engine',
    priority: 'required',
    condition: (p) => p?.domain === 'automation',
    transform: identity,
  },
  {
    id: 'auto.triggers',
    text: 'Which trigger types should be supported?',
    type: 'multi-choice',
    options: ['cron', 'webhook', 'file-change', 'event', 'manual', 'api-call'],
    default: ['cron', 'webhook', 'manual'],
    priority: 'required',
    condition: (p) => p?.domain === 'automation',
    transform: csvToArray,
  },
  {
    id: 'auto.task_definition',
    text: 'How should tasks / workflows be defined?',
    type: 'choice',
    options: ['code', 'yaml', 'json', 'visual', 'hybrid'],
    default: 'code',
    priority: 'required',
    condition: (p) => p?.domain === 'automation',
    transform: identity,
  },
  {
    id: 'auto.concurrency',
    text: 'Should the framework support concurrent task execution?',
    type: 'confirm',
    options: [],
    default: true,
    priority: 'required',
    condition: (p) => p?.domain === 'automation',
    transform: toBool,
  },
  {
    id: 'auto.dependency_graph',
    text: 'Include a task dependency graph (DAG) engine?',
    type: 'confirm',
    options: [],
    default: true,
    priority: 'recommended',
    condition: (p) => p?.domain === 'automation',
    transform: toBool,
  },
  {
    id: 'auto.retry',
    text: 'Include configurable retry / backoff strategies?',
    type: 'confirm',
    options: [],
    default: true,
    priority: 'recommended',
    condition: (p) => p?.domain === 'automation',
    transform: toBool,
  },
  {
    id: 'auto.state_persistence',
    text: 'Persist workflow state between runs?',
    type: 'confirm',
    options: [],
    default: true,
    priority: 'recommended',
    condition: (p) => p?.domain === 'automation',
    transform: toBool,
  },
  {
    id: 'auto.notifications',
    text: 'Include notification channels (email, Slack, webhook)?',
    type: 'confirm',
    options: [],
    default: false,
    priority: 'optional',
    condition: (p) => p?.domain === 'automation',
    transform: toBool,
  },
  {
    id: 'auto.sandboxing',
    text: 'Should tasks run in sandboxed environments?',
    type: 'confirm',
    options: [],
    default: false,
    priority: 'optional',
    condition: (p) => p?.domain === 'automation',
    transform: toBool,
  },
  {
    id: 'auto.dashboard',
    text: 'Include a web dashboard for monitoring workflow execution?',
    type: 'confirm',
    options: [],
    default: false,
    priority: 'optional',
    condition: (p) => p?.domain === 'automation' && p?.scalability !== 'small',
    transform: toBool,
  },
];

// ---- 3h. Plugin Domain ----

/** @type {QuestionDefinition[]} */
const pluginQuestions = [
  {
    id: 'plugin.host',
    text: 'What is the host application for the plugin system?',
    type: 'choice',
    options: ['editor', 'cli', 'web-app', 'desktop-app', 'server', 'generic'],
    default: 'generic',
    priority: 'required',
    condition: (p) => p?.domain === 'plugin',
    transform: identity,
  },
  {
    id: 'plugin.api_surface',
    text: 'How should plugins interact with the host?',
    type: 'choice',
    options: ['api-object', 'hooks', 'events', 'decorators', 'hybrid'],
    default: 'hooks',
    priority: 'required',
    condition: (p) => p?.domain === 'plugin',
    transform: identity,
  },
  {
    id: 'plugin.lifecycle',
    text: 'Which plugin lifecycle hooks should be provided?',
    type: 'multi-choice',
    options: ['activate', 'deactivate', 'install', 'uninstall', 'update', 'configure'],
    default: ['activate', 'deactivate', 'install', 'uninstall'],
    priority: 'required',
    condition: (p) => p?.domain === 'plugin',
    transform: csvToArray,
  },
  {
    id: 'plugin.isolation',
    text: 'Should plugins run in isolated contexts (sandboxed)?',
    type: 'confirm',
    options: [],
    default: true,
    priority: 'recommended',
    condition: (p) => p?.domain === 'plugin',
    transform: toBool,
  },
  {
    id: 'plugin.dependency_management',
    text: 'Should the framework manage plugin dependencies automatically?',
    type: 'confirm',
    options: [],
    default: true,
    priority: 'recommended',
    condition: (p) => p?.domain === 'plugin',
    transform: toBool,
  },
  {
    id: 'plugin.marketplace',
    text: 'Include a plugin registry / marketplace abstraction?',
    type: 'confirm',
    options: [],
    default: false,
    priority: 'optional',
    condition: (p) => p?.domain === 'plugin',
    transform: toBool,
  },
  {
    id: 'plugin.versioning',
    text: 'Support multiple plugin versions running simultaneously?',
    type: 'confirm',
    options: [],
    default: false,
    priority: 'optional',
    condition: (p) => p?.domain === 'plugin',
    transform: toBool,
  },
  {
    id: 'plugin.hot_reload',
    text: 'Support hot-reloading of plugins at runtime?',
    type: 'confirm',
    options: [],
    default: true,
    priority: 'recommended',
    condition: (p) => p?.domain === 'plugin',
    transform: toBool,
  },
  {
    id: 'plugin.permissions',
    text: 'Include a capability / permission system for plugins?',
    type: 'confirm',
    options: [],
    default: true,
    priority: 'recommended',
    condition: (p) => p?.domain === 'plugin',
    transform: toBool,
  },
  {
    id: 'plugin.settings_schema',
    text: 'Should each plugin declare a settings schema for validation?',
    type: 'confirm',
    options: [],
    default: true,
    priority: 'recommended',
    condition: (p) => p?.domain === 'plugin',
    transform: toBool,
  },
];

// ---------------------------------------------------------------------------
// 4. Integration Questions
// ---------------------------------------------------------------------------

/** @type {QuestionDefinition[]} */
const integrationQuestions = [
  {
    id: 'int.databases',
    text: 'Which databases should the framework integrate with?',
    type: 'multi-choice',
    options: ['postgres', 'mysql', 'mongodb', 'redis', 'sqlite', 'dynamodb', 'none'],
    default: ['none'],
    priority: 'recommended',
    condition: (p) => p?.domain !== 'cli' && p?.domain !== 'testing',
    transform: csvToArray,
  },
  {
    id: 'int.message_queues',
    text: 'Include message queue integration?',
    type: 'multi-choice',
    options: ['rabbitmq', 'kafka', 'sqs', 'redis-streams', 'nats', 'none'],
    default: ['none'],
    priority: 'optional',
    condition: (p) => ['api', 'data', 'automation', 'ai-agent'].includes(p?.domain),
    transform: csvToArray,
  },
  {
    id: 'int.cloud_storage',
    text: 'Include cloud storage integration?',
    type: 'multi-choice',
    options: ['s3', 'gcs', 'azure-blob', 'local-fs', 'none'],
    default: ['none'],
    priority: 'optional',
    condition: (p) => ['api', 'data', 'automation'].includes(p?.domain),
    transform: csvToArray,
  },
  {
    id: 'int.monitoring',
    text: 'Which observability tools should be integrated?',
    type: 'multi-choice',
    options: ['prometheus', 'opentelemetry', 'datadog', 'custom-metrics', 'none'],
    default: ['none'],
    priority: 'optional',
    condition: always,
    transform: csvToArray,
  },
  {
    id: 'int.auth_providers',
    text: 'Include third-party auth provider integration?',
    type: 'multi-choice',
    options: ['auth0', 'firebase-auth', 'cognito', 'supabase', 'custom', 'none'],
    default: ['none'],
    priority: 'optional',
    condition: (p) => ['api', 'ui'].includes(p?.domain),
    transform: csvToArray,
  },
  {
    id: 'int.email',
    text: 'Include email sending integration?',
    type: 'multi-choice',
    options: ['sendgrid', 'ses', 'mailgun', 'smtp', 'none'],
    default: ['none'],
    priority: 'optional',
    condition: (p) => ['api', 'automation'].includes(p?.domain),
    transform: csvToArray,
  },
];

// ---------------------------------------------------------------------------
// 5. Testing-Strategy Questions (applies to every domain)
// ---------------------------------------------------------------------------

/** @type {QuestionDefinition[]} */
const testingStrategyQuestions = [
  {
    id: 'test.unit',
    text: 'Include unit testing setup?',
    type: 'confirm',
    options: [],
    default: true,
    priority: 'required',
    condition: always,
    transform: toBool,
  },
  {
    id: 'test.integration',
    text: 'Include integration testing setup?',
    type: 'confirm',
    options: [],
    default: true,
    priority: 'recommended',
    condition: always,
    transform: toBool,
  },
  {
    id: 'test.e2e',
    text: 'Include end-to-end (E2E) testing setup?',
    type: 'confirm',
    options: [],
    default: false,
    priority: 'recommended',
    condition: always,
    transform: toBool,
  },
  {
    id: 'test.coverage_threshold',
    text: 'Minimum code-coverage threshold (1-10 scale, where 10 = 100%)?',
    type: 'scale',
    options: [],
    default: 7,
    priority: 'optional',
    condition: (p) => p?.testing?.unit === true,
    transform: clampScale,
  },
];

// ---------------------------------------------------------------------------
// 6. Deployment Questions
// ---------------------------------------------------------------------------

/** @type {QuestionDefinition[]} */
const deploymentQuestions = [
  {
    id: 'deploy.docker',
    text: 'Generate a Dockerfile and docker-compose setup?',
    type: 'confirm',
    options: [],
    default: true,
    priority: 'recommended',
    condition: always,
    transform: toBool,
  },
  {
    id: 'deploy.ci',
    text: 'Which CI/CD system should be configured?',
    type: 'choice',
    options: ['github-actions', 'gitlab-ci', 'circleci', 'none'],
    default: 'github-actions',
    priority: 'recommended',
    condition: always,
    transform: identity,
  },
  {
    id: 'deploy.cloud',
    text: 'Target cloud platform?',
    type: 'choice',
    options: ['aws', 'gcp', 'azure', 'vercel', 'fly', 'self-hosted', 'none'],
    default: 'none',
    priority: 'optional',
    condition: always,
    transform: identity,
  },
  {
    id: 'deploy.env_management',
    text: 'How should environment variables be managed?',
    type: 'choice',
    options: ['dotenv', 'vault', 'cloud-native', 'none'],
    default: 'dotenv',
    priority: 'recommended',
    condition: always,
    transform: identity,
  },
  {
    id: 'deploy.release_strategy',
    text: 'Preferred release strategy?',
    type: 'choice',
    options: ['semver-manual', 'conventional-commits', 'calver', 'none'],
    default: 'conventional-commits',
    priority: 'optional',
    condition: always,
    transform: identity,
  },
];

// ---------------------------------------------------------------------------
// 7. Claude Code Integration Questions
// ---------------------------------------------------------------------------

/** @type {QuestionDefinition[]} */
const claudeCodeQuestions = [
  {
    id: 'claude.generate_claude_md',
    text: 'Generate a CLAUDE.md file for the framework?',
    type: 'confirm',
    options: [],
    default: true,
    priority: 'required',
    condition: always,
    transform: toBool,
  },
  {
    id: 'claude.slash_commands',
    text: 'Which slash commands should be generated?',
    type: 'multi-choice',
    options: ['create', 'test', 'deploy', 'lint', 'docs', 'debug', 'refactor'],
    default: ['create', 'test', 'lint'],
    priority: 'recommended',
    condition: always,
    transform: csvToArray,
  },
  {
    id: 'claude.mcp_servers',
    text: 'Which MCP server integrations should be included?',
    type: 'multi-choice',
    options: ['filesystem', 'database', 'git', 'http', 'custom', 'none'],
    default: ['filesystem', 'git'],
    priority: 'recommended',
    condition: always,
    transform: csvToArray,
  },
  {
    id: 'claude.behavioral_rules',
    text: 'How many behavioral rules should the CLAUDE.md include (1-10)?',
    type: 'scale',
    options: [],
    default: 7,
    priority: 'optional',
    condition: (p) => p?.claudeCode?.generate_claude_md === true,
    transform: clampScale,
  },
  {
    id: 'claude.file_reading_order',
    text: 'Should CLAUDE.md include an explicit file-reading order?',
    type: 'confirm',
    options: [],
    default: true,
    priority: 'optional',
    condition: (p) => p?.claudeCode?.generate_claude_md === true,
    transform: toBool,
  },
];

// ---------------------------------------------------------------------------
// Composite Question Map
// ---------------------------------------------------------------------------

/**
 * All question categories mapped by their key.
 *
 * @type {Record<string, QuestionDefinition[]>}
 */
const QUESTION_CATEGORIES = {
  common: commonQuestions,
  architecture: architectureQuestions,
  api: apiQuestions,
  cli: cliQuestions,
  testing: testingQuestions,
  ui: uiQuestions,
  data: dataQuestions,
  'ai-agent': aiAgentQuestions,
  automation: automationQuestions,
  plugin: pluginQuestions,
  integration: integrationQuestions,
  testingStrategy: testingStrategyQuestions,
  deployment: deploymentQuestions,
  claudeCode: claudeCodeQuestions,
};

/**
 * Domain-specific category keys indexed by domain name.
 *
 * @type {Record<string, string>}
 */
const DOMAIN_CATEGORY_MAP = {
  api: 'api',
  cli: 'cli',
  testing: 'testing',
  ui: 'ui',
  data: 'data',
  'ai-agent': 'ai-agent',
  automation: 'automation',
  plugin: 'plugin',
};

// ---------------------------------------------------------------------------
// Public API
// ---------------------------------------------------------------------------

/**
 * Returns a flat array of all questions applicable for the given domain,
 * ordered by presentation priority: common -> domain-specific -> architecture
 * -> integration -> testing strategy -> deployment -> Claude Code.
 *
 * @param {string} domain - The primary framework domain.
 * @returns {QuestionDefinition[]} Ordered question list.
 */
export function getQuestionsForDomain(domain) {
  const domainCategory = DOMAIN_CATEGORY_MAP[domain];
  const domainSpecificQuestions = domainCategory
    ? QUESTION_CATEGORIES[domainCategory] ?? []
    : [];

  return [
    ...commonQuestions,
    ...domainSpecificQuestions,
    ...architectureQuestions,
    ...integrationQuestions,
    ...testingStrategyQuestions,
    ...deploymentQuestions,
    ...claudeCodeQuestions,
  ];
}

/**
 * Returns all questions across every category (useful for validation).
 *
 * @returns {QuestionDefinition[]}
 */
export function getAllQuestions() {
  return Object.values(QUESTION_CATEGORIES).flat();
}

/**
 * Looks up a single question by its unique id.
 *
 * @param {string} id - Question id (e.g. "api.protocol").
 * @returns {QuestionDefinition | undefined}
 */
export function getQuestionById(id) {
  for (const questions of Object.values(QUESTION_CATEGORIES)) {
    const found = questions.find((q) => q.id === id);
    if (found) return found;
  }
  return undefined;
}

/**
 * Returns only the questions whose condition passes for the given profile.
 *
 * @param {QuestionDefinition[]} questions - Question list to filter.
 * @param {Object}               profile   - Partial RequirementsProfile.
 * @returns {QuestionDefinition[]}
 */
export function filterApplicableQuestions(questions, profile) {
  return questions.filter((q) => {
    try {
      return q.condition(profile);
    } catch {
      return false;
    }
  });
}

export {
  QUESTION_CATEGORIES,
  DOMAIN_CATEGORY_MAP,
  commonQuestions,
  architectureQuestions,
  apiQuestions,
  cliQuestions,
  testingQuestions,
  uiQuestions,
  dataQuestions,
  aiAgentQuestions,
  automationQuestions,
  pluginQuestions,
  integrationQuestions,
  testingStrategyQuestions,
  deploymentQuestions,
  claudeCodeQuestions,
};
