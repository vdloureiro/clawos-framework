/**
 * @module CommonPartials
 * @description Reusable template partials for the ClawOS meta-framework.
 * Each partial is a template string that can be registered with the
 * TemplateEngine and included via {{> partialName}} syntax.
 *
 * @author ClawOS Framework
 * @license MIT
 */

// ---------------------------------------------------------------------------
// Partials map
// ---------------------------------------------------------------------------

/**
 * Collection of reusable template partials.
 * Keys are the partial names (used with {{> name}}), values are template strings.
 *
 * @type {Record<string, string>}
 */
const commonPartials = {
  // -----------------------------------------------------------------------
  // header — File header comment with name, description, author, date
  // -----------------------------------------------------------------------
  header: `/**
 * @module {{moduleName}}
{{#if description}}
 * @description {{description}}
{{/if}}
{{#if author}}
 * @author {{author}}
{{/if}}
 * @created {{date}}
{{#if version}}
 * @version {{version}}
{{/if}}
 * @license {{#if license}}{{license}}{{/if}}{{#unless license}}MIT{{/unless}}
 *
 * This file was generated by ClawOS Framework.
 * Manual edits are preserved — the generator will not overwrite them.
 */
`,

  // -----------------------------------------------------------------------
  // license-mit — Full MIT license text
  // -----------------------------------------------------------------------
  'license-mit': `MIT License

Copyright (c) {{year}} {{author}}

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
`,

  // -----------------------------------------------------------------------
  // imports-node — Common Node.js imports
  // -----------------------------------------------------------------------
  'imports-node': `import { readFile, writeFile, mkdir, stat } from 'node:fs/promises';
import { existsSync } from 'node:fs';
import { resolve, join, dirname, basename, extname } from 'node:path';
import { fileURLToPath } from 'node:url';
import { EventEmitter } from 'node:events';
import process from 'node:process';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
`,

  // -----------------------------------------------------------------------
  // error-class — Custom error class definition
  // -----------------------------------------------------------------------
  'error-class': `/**
 * @class {{errorName | pascalCase}}Error
 * @extends Error
 * @description Custom error class for {{moduleName}} operations.
 */
class {{errorName | pascalCase}}Error extends Error {
  /**
   * @param {string} message — human-readable error description
   * @param {Object} [options={}]
   * @param {string} [options.code]  — machine-readable error code
   * @param {Error}  [options.cause] — the underlying error, if any
   * @param {Object} [options.meta]  — additional context
   */
  constructor(message, { code, cause, meta } = {}) {
    super(message, { cause });
    this.name = '{{errorName | pascalCase}}Error';
    this.code = code || '{{errorName | snakeCase | uppercase}}_ERROR';
    this.meta = meta || {};
    this.timestamp = new Date().toISOString();

    // Capture a clean stack trace (V8 only)
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, {{errorName | pascalCase}}Error);
    }
  }

  /**
   * Serialize for logging / transport.
   * @returns {Object}
   */
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      code: this.code,
      meta: this.meta,
      timestamp: this.timestamp,
      stack: this.stack,
      ...(this.cause ? { cause: String(this.cause) } : {}),
    };
  }
}
`,

  // -----------------------------------------------------------------------
  // logger-setup — Logger initialization
  // -----------------------------------------------------------------------
  'logger-setup': `/**
 * Lightweight structured logger.
 * No external dependencies — writes to stdout/stderr.
 */
const LOG_LEVELS = { debug: 0, info: 1, warn: 2, error: 3, silent: 4 };

function createLogger(name, { level = 'info' } = {}) {
  const threshold = LOG_LEVELS[level] ?? LOG_LEVELS.info;

  function write(lvl, ...args) {
    if (LOG_LEVELS[lvl] < threshold) return;
    const ts = new Date().toISOString();
    const prefix = \`[\${ts}] [\${lvl.toUpperCase()}] [\${name}]\`;
    const stream = lvl === 'error' || lvl === 'warn' ? console.error : console.log;
    stream(prefix, ...args);
  }

  return {
    debug: (...args) => write('debug', ...args),
    info:  (...args) => write('info', ...args),
    warn:  (...args) => write('warn', ...args),
    error: (...args) => write('error', ...args),
  };
}

const logger = createLogger('{{moduleName}}', { level: '{{#if logLevel}}{{logLevel}}{{/if}}{{#unless logLevel}}info{{/unless}}' });
`,

  // -----------------------------------------------------------------------
  // config-loader — Config file loader
  // -----------------------------------------------------------------------
  'config-loader': `import { readFile } from 'node:fs/promises';
import { resolve } from 'node:path';

/**
 * Load and merge a JSON/JS configuration file with default values.
 *
 * @param {Object} defaults  — base configuration
 * @param {string} [configPath] — optional path to a JSON config file
 * @returns {Promise<Object>} merged configuration
 */
async function loadConfig(defaults = {}, configPath) {
  if (!configPath) return { ...defaults };

  const absPath = resolve(configPath);
  let fileConfig = {};

  try {
    if (absPath.endsWith('.json')) {
      const raw = await readFile(absPath, 'utf-8');
      fileConfig = JSON.parse(raw);
    } else if (absPath.endsWith('.js') || absPath.endsWith('.mjs')) {
      const mod = await import(absPath);
      fileConfig = mod.default ?? mod;
    }
  } catch (err) {
    if (err.code !== 'ENOENT') {
      throw new Error(\`Failed to load config from \${absPath}: \${err.message}\`, { cause: err });
    }
    // Config file does not exist — use defaults silently
  }

  return deepMerge(defaults, fileConfig);
}

/**
 * Recursively merge source into target (immutable).
 * @param {Object} target
 * @param {Object} source
 * @returns {Object}
 */
function deepMerge(target, source) {
  const result = { ...target };
  for (const key of Object.keys(source)) {
    if (
      source[key] &&
      typeof source[key] === 'object' &&
      !Array.isArray(source[key]) &&
      target[key] &&
      typeof target[key] === 'object' &&
      !Array.isArray(target[key])
    ) {
      result[key] = deepMerge(target[key], source[key]);
    } else {
      result[key] = source[key];
    }
  }
  return result;
}
`,

  // -----------------------------------------------------------------------
  // event-emitter-setup — EventEmitter extension boilerplate
  // -----------------------------------------------------------------------
  'event-emitter-setup': `import { EventEmitter } from 'node:events';

/**
 * @class {{className | pascalCase}}
 * @extends EventEmitter
 * @description {{description}}
 *
 * Events:
 *   - 'ready'            — emitted after successful initialization
 *   - 'error'   (err)    — emitted on unrecoverable error
 *   - 'message' (data)   — emitted when a message is received
 *   - 'close'            — emitted on shutdown
 */
class {{className | pascalCase}} extends EventEmitter {
  #ready = false;

  constructor(options = {}) {
    super();
    this.options = { ...options };
  }

  /**
   * Initialize and emit 'ready'.
   * @returns {Promise<void>}
   */
  async init() {
    this.#ready = true;
    this.emit('ready');
  }

  /**
   * Shut down and emit 'close'.
   * @returns {Promise<void>}
   */
  async close() {
    this.#ready = false;
    this.emit('close');
    this.removeAllListeners();
  }

  /**
   * Whether the instance is initialized and ready.
   * @returns {boolean}
   */
  get isReady() {
    return this.#ready;
  }
}
`,

  // -----------------------------------------------------------------------
  // cli-help — CLI help text generator
  // -----------------------------------------------------------------------
  'cli-help': `/**
 * Generate formatted CLI help text.
 *
 * @param {Object} config
 * @param {string} config.name        — command name
 * @param {string} config.version     — version string
 * @param {string} config.description — one-line description
 * @param {Array<{flags: string, description: string}>} config.options
 * @param {Array<{name: string, description: string}>} [config.commands]
 * @returns {string}
 */
function generateHelp({ name, version, description, options = [], commands = [] }) {
  const lines = [];

  lines.push(\`\${name} v\${version}\`);
  lines.push(description);
  lines.push('');
  lines.push(\`Usage: \${name} [command] [options]\`);
  lines.push('');

  if (commands.length > 0) {
    lines.push('Commands:');
    const maxCmd = Math.max(...commands.map((c) => c.name.length));
    for (const cmd of commands) {
      lines.push(\`  \${cmd.name.padEnd(maxCmd + 4)}\${cmd.description}\`);
    }
    lines.push('');
  }

  if (options.length > 0) {
    lines.push('Options:');
    const maxFlag = Math.max(...options.map((o) => o.flags.length));
    for (const opt of options) {
      lines.push(\`  \${opt.flags.padEnd(maxFlag + 4)}\${opt.description}\`);
    }
    lines.push('');
  }

  return lines.join('\\n');
}
`,

  // -----------------------------------------------------------------------
  // test-setup — Test file setup/teardown boilerplate
  // -----------------------------------------------------------------------
  'test-setup': `/**
 * Shared test utilities — setup and teardown helpers.
 */

import { mkdir, rm } from 'node:fs/promises';
import { join } from 'node:path';
import { tmpdir } from 'node:os';
import { randomUUID } from 'node:crypto';

/**
 * Create a temporary directory for the test run.
 * @returns {Promise<string>} absolute path to the temp directory
 */
async function createTempDir() {
  const dir = join(tmpdir(), '{{projectName | kebabCase}}-test-' + randomUUID().slice(0, 8));
  await mkdir(dir, { recursive: true });
  return dir;
}

/**
 * Remove a temporary directory and all its contents.
 * @param {string} dir — path returned by createTempDir
 * @returns {Promise<void>}
 */
async function removeTempDir(dir) {
  await rm(dir, { recursive: true, force: true });
}

/**
 * Wait for a given number of milliseconds.
 * Useful for testing debounced or async operations.
 * @param {number} ms
 * @returns {Promise<void>}
 */
function wait(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

/**
 * Capture console output during a callback.
 * @param {Function} fn — async function to execute
 * @returns {Promise<{stdout: string[], stderr: string[]}>}
 */
async function captureConsole(fn) {
  const stdout = [];
  const stderr = [];
  const origLog = console.log;
  const origErr = console.error;
  console.log = (...args) => stdout.push(args.join(' '));
  console.error = (...args) => stderr.push(args.join(' '));
  try {
    await fn();
  } finally {
    console.log = origLog;
    console.error = origErr;
  }
  return { stdout, stderr };
}
`,
};

export default commonPartials;
export { commonPartials };
