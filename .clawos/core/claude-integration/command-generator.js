/**
 * @module claude-integration/command-generator
 * @description Generates Claude Code slash command files (.claude/commands/*.md) for
 * frameworks produced by ClawOS.
 *
 * Each generated command is a detailed Markdown prompt file that guides Claude Code
 * through a specific workflow — creating endpoints, adding tests, scaffolding
 * components, and more. Commands are tailored to the framework's domain and
 * architecture so Claude can operate with full context.
 *
 * @author ClawOS Framework
 * @license MIT
 */

import { promises as fs } from 'node:fs';
import path from 'node:path';

// ---------------------------------------------------------------------------
// Internal helpers
// ---------------------------------------------------------------------------

/**
 * Capitalize the first letter of a string.
 * @param {string} s
 * @returns {string}
 */
function capitalize(s) {
  if (!s) return '';
  return s.charAt(0).toUpperCase() + s.slice(1);
}

/**
 * Convert a kebab-case or snake_case string to Title Case.
 * @param {string} s
 * @returns {string}
 */
function toTitleCase(s) {
  return s
    .replace(/[-_]/g, ' ')
    .replace(/\b\w/g, (c) => c.toUpperCase());
}

/**
 * Sanitize a project name into a safe command prefix (lowercase, kebab-case).
 * @param {string} name
 * @returns {string}
 */
function toCommandPrefix(name) {
  return name
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '');
}

// ---------------------------------------------------------------------------
// Type imports (JSDoc only)
// ---------------------------------------------------------------------------

/**
 * @typedef {import('../blueprint/blueprint-engine.js').RequirementsProfile} RequirementsProfile
 * @typedef {import('../blueprint/blueprint-engine.js').Blueprint} Blueprint
 */

/**
 * @typedef {Object} GeneratedCommand
 * @property {string} name       - Command name (e.g., "myapp:help").
 * @property {string} filename   - File name on disk (e.g., "myapp-help.md").
 * @property {string} content    - Full Markdown content of the command prompt.
 * @property {string} outputPath - Absolute path where the file was (or will be) written.
 */

// ---------------------------------------------------------------------------
// Base command templates
// ---------------------------------------------------------------------------

/**
 * Generate the help command content.
 * @param {string} name - Project name.
 * @param {string} domain - Project domain.
 * @param {Blueprint} blueprint
 * @returns {string}
 */
function helpCommandContent(name, domain, blueprint) {
  const layers = (blueprint.metadata.layers || []).map((l) => `- \`${l}\``).join('\n');
  const modules = (blueprint.modules || [])
    .map((m) => `- **${toTitleCase(m.name)}** (\`${m.path}\`) — ${m.responsibility}`)
    .join('\n');

  return `# ${name}:help — Framework Help

You are an assistant working within the **${name}** framework, a **${toTitleCase(domain)}** project
generated by ClawOS.

## Your Task

Display a comprehensive help overview for this project. Gather and present the
following information by reading the project files:

1. **Project summary** — Read \`package.json\` and \`README.md\` for the project
   description, version, and author.

2. **Architecture** — This project uses a **${toTitleCase(blueprint.archetype)}** architecture
   with these layers:
${layers}

3. **Key modules:**
${modules}

4. **Available commands** — List all slash commands available in \`.claude/commands/\`.
   For each command, show its name and a one-line description extracted from the
   first heading in the file.

5. **Configuration** — Summarize the configuration format (\`${blueprint.config.format}\`)
   and list config files.

6. **Quick start** — Show the commands to install dependencies, run the project,
   and run tests.

## Output Format

Present the information in a well-structured, readable format using Markdown
headings and bullet lists. Keep descriptions concise. If any file is missing,
note it and suggest how to create it.

## Important

- Do NOT modify any files. This is a read-only informational command.
- If the project structure differs from what is documented here, describe what
  you actually find on disk rather than what is expected.
`;
}

/**
 * Generate the status command content.
 * @param {string} name - Project name.
 * @param {string} domain - Project domain.
 * @param {Blueprint} blueprint
 * @returns {string}
 */
function statusCommandContent(name, domain, blueprint) {
  const configFiles = (blueprint.config.files || []).map((f) => `- \`${f}\``).join('\n');

  return `# ${name}:status — Project Status and Health

You are an assistant working within the **${name}** framework, a **${toTitleCase(domain)}** project.

## Your Task

Perform a comprehensive health check of the project and report its current status.
Check each of the following areas:

### 1. Dependency Health
- Read \`package.json\` and check if \`node_modules/\` exists.
- Look for outdated or missing dependencies.
- Check for a lock file (\`package-lock.json\`, \`yarn.lock\`, or \`pnpm-lock.yaml\`).

### 2. Configuration Health
- Verify these configuration files exist and are valid:
${configFiles || '- (no config files defined)'}
- Check for a \`.env\` file or \`.env.example\`.
- Verify \`.gitignore\` is present and covers common patterns.

### 3. Source Code Health
- Verify the entry point (\`src/index.js\`) exists.
- Check that each architecture layer has its barrel export (\`index.js\`).
- Look for any empty source directories.
- Count total source files and lines of code.

### 4. Test Health
- Check if the \`tests/\` directory exists with test files.
- If a test runner is configured, run \`npm test\` and report results.
- Report test coverage if available.

### 5. Documentation Health
- Check for \`README.md\`, \`CLAUDE.md\`, and any \`docs/\` content.
- Flag missing or empty documentation files.

### 6. Git Health
- Check if the project is a git repository.
- Report the current branch, uncommitted changes, and last commit message.

## Output Format

Present a status dashboard using this format:

\`\`\`
[OK]   Area — Details
[WARN] Area — Details
[FAIL] Area — Details
\`\`\`

End with a summary: total checks, passed, warnings, and failures.

## Important

- Only run read-only commands. Do NOT modify files or install packages.
- If a check cannot be performed (e.g., no test runner), mark it as [SKIP].
`;
}

/**
 * Generate the test command content.
 * @param {string} name - Project name.
 * @param {string} domain - Project domain.
 * @param {Blueprint} blueprint
 * @returns {string}
 */
function testCommandContent(name, domain, blueprint) {
  return `# ${name}:test — Run Tests with Guidance

You are an assistant working within the **${name}** framework, a **${toTitleCase(domain)}** project.

## Your Task

Run the project's test suite and provide detailed guidance on the results.

### Step 1: Discover Test Configuration
- Read \`package.json\` to find the test script and test runner.
- Check for test configuration files (e.g., \`jest.config.js\`, \`vitest.config.js\`,
  \`.mocharc.yml\`).
- Identify the test directory structure (\`tests/unit/\`, \`tests/integration/\`, etc.).

### Step 2: Run Tests
- Execute \`npm test\` to run the full test suite.
- If specific test types are available, also note how to run them individually:
  - Unit tests: \`npm run test:unit\`
  - Integration tests: \`npm run test:integration\`
  - Coverage: \`npm run test:coverage\`

### Step 3: Analyze Results
For each test result:
- **Passing tests**: Confirm they pass and briefly note what they cover.
- **Failing tests**: For each failure, provide:
  - The test name and file location.
  - The assertion that failed and the expected vs. actual values.
  - A specific suggestion for how to fix the failure.
- **Skipped tests**: Note any skipped tests and why they might be skipped.

### Step 4: Coverage Analysis (if available)
- Report overall code coverage percentage.
- Identify modules with low coverage (<60%).
- Suggest which untested code paths are most critical to cover.

### Step 5: Recommendations
- Suggest any missing test cases based on the project architecture.
- For the **${toTitleCase(blueprint.archetype)}** architecture, ensure each layer
  (${(blueprint.metadata.layers || []).join(', ')}) has adequate test coverage.
- Recommend test improvements (better assertions, edge cases, mocks).

## Output Format

Structure your response with clear sections for each step. Use code blocks for
test output. Highlight failures prominently so they are easy to find and fix.

## Important

- Run tests in the project directory.
- If tests modify state, note any cleanup that may be needed.
- If no tests exist yet, provide a template for the first test file.
`;
}

// ---------------------------------------------------------------------------
// Domain-specific command templates
// ---------------------------------------------------------------------------

/**
 * @type {Record<string, (name: string, domain: string, blueprint: Blueprint) => [string, string][]>}
 */
const DOMAIN_COMMAND_FACTORIES = {
  api: (name, domain, blueprint) => [
    [
      'endpoint',
      `# ${name}:endpoint — Create a New API Endpoint

You are an assistant working within the **${name}** framework, a **${toTitleCase(domain)}** project.

## Your Task

Create a new API endpoint. The user will provide the endpoint details (or ask
you to infer them from context).

### Information to Gather

If not provided, ask for:
1. **HTTP method** (GET, POST, PUT, PATCH, DELETE)
2. **Route path** (e.g., \`/api/users/:id\`)
3. **Resource name** (e.g., "users", "products")
4. **Purpose** (CRUD operation, custom action, etc.)

### Files to Create/Modify

Follow the **${toTitleCase(blueprint.archetype)}** layered architecture:

1. **Route definition** — Add the route in the routing layer.
   - File: \`src/routing/\` or relevant routes file.
   - Register the HTTP method, path, and controller handler.

2. **Controller** — Create or update the controller.
   - File: \`src/controller/<resource>.controller.js\`
   - Implement request parsing, call the service layer, and format the response.
   - Include input validation using the project's validation approach.

3. **Service** — Create or update the service function.
   - File: \`src/service/<resource>.service.js\`
   - Implement the business logic. Keep it independent of HTTP concerns.

4. **Data layer** (if needed) — Add repository methods.
   - File: \`src/data/<resource>.repository.js\`
   - Add database queries or data access methods.

5. **Tests** — Create tests for the new endpoint.
   - Unit test: \`tests/unit/<resource>.service.test.js\`
   - Integration test: \`tests/integration/<resource>.endpoint.test.js\`

### Coding Standards

- Use async/await for all asynchronous operations.
- Return proper HTTP status codes (200, 201, 204, 400, 404, 500).
- Follow the existing error handling pattern in the project.
- Add JSDoc comments to all new functions.
- Validate all request inputs before processing.
- Use structured error responses: \`{ "error": { "code": string, "message": string } }\`.

### Output

After creating the files, provide:
1. A summary of all files created or modified.
2. A curl example showing how to call the new endpoint.
3. Instructions for running the related tests.
`,
    ],
    [
      'middleware',
      `# ${name}:middleware — Add Middleware

You are an assistant working within the **${name}** framework, a **${toTitleCase(domain)}** project.

## Your Task

Create and register a new middleware function in the API pipeline.

### Information to Gather

If not provided, ask for:
1. **Middleware name** (e.g., "rateLimiter", "cors", "requestLogger")
2. **Purpose** — What the middleware does (authentication, logging, validation, etc.)
3. **Scope** — Global (all routes) or route-specific
4. **Position** — Where in the pipeline it should execute (before auth, after parsing, etc.)

### Implementation Steps

1. **Create the middleware file:**
   - File: \`src/middleware/<name>.middleware.js\`
   - Export a function with the signature: \`(req, res, next) => { ... }\`
   - Include proper error handling — call \`next(error)\` on failure.
   - Add configuration options as factory parameters if the middleware is configurable.

2. **Register the middleware:**
   - If global: Add it to the main app/server setup in the appropriate order.
   - If route-specific: Document which routes should use it.
   - Respect the existing middleware ordering in the project.

3. **Add barrel export:**
   - Update \`src/middleware/index.js\` to export the new middleware.

4. **Write tests:**
   - File: \`tests/unit/<name>.middleware.test.js\`
   - Test: the happy path, error handling, edge cases, and configuration options.
   - Mock \`req\`, \`res\`, and \`next\` appropriately.

5. **Update documentation:**
   - Add the middleware to the middleware pipeline documentation.
   - Document configuration options and default values.

### Coding Standards

- Middleware must be stateless — do not store request-specific data in closures.
- Use the factory pattern for configurable middleware: \`createMiddleware(options)\`.
- Always call \`next()\` or send a response — never leave the request hanging.
- Log middleware actions at the \`debug\` level, errors at the \`error\` level.
- Include timing information for performance-sensitive middleware.

### Output

After creating the files, provide:
1. Summary of files created/modified.
2. Example of how the middleware is registered.
3. Example request showing the middleware in action.
`,
    ],
    [
      'migrate',
      `# ${name}:migrate — Database Migration

You are an assistant working within the **${name}** framework, a **${toTitleCase(domain)}** project.

## Your Task

Create or run a database migration for schema changes.

### Information to Gather

If not provided, ask for:
1. **Migration type**: create table, alter table, add index, seed data, or custom
2. **Table/collection name**
3. **Schema changes**: columns to add/remove/modify with their types
4. **Relationships**: foreign keys or references to other tables

### Implementation Steps

1. **Create the migration file:**
   - File: \`src/data/migrations/<timestamp>-<description>.js\`
   - Use a timestamp prefix for ordering (e.g., \`20250101120000-create-users.js\`).
   - Export \`up()\` and \`down()\` functions for forward and reverse migration.

2. **Implement the up migration:**
   - Create/alter tables with proper column types and constraints.
   - Add indexes for frequently queried columns.
   - Set NOT NULL, DEFAULT, and UNIQUE constraints as appropriate.

3. **Implement the down migration:**
   - Reverse every change made in \`up()\` exactly.
   - Drop tables, remove columns, or drop indexes in reverse order.
   - Ensure the down migration is safe to run multiple times (idempotent).

4. **Update model/repository (if applicable):**
   - Update the data model to reflect the new schema.
   - Add/update repository methods for new columns or tables.

5. **Write tests:**
   - Test that the migration runs successfully (up and down).
   - Test that data integrity is preserved after migration.

### Coding Standards

- Migrations must be idempotent — safe to run multiple times.
- Always provide a reversible \`down()\` function.
- Use transactions where supported by the database.
- Never modify an existing migration that has been run — create a new one.
- Document the purpose of each migration in a comment at the top of the file.

### Output

Provide:
1. The complete migration file.
2. Instructions for running the migration.
3. The updated model/repository if applicable.
4. SQL preview of what the migration will execute.
`,
    ],
  ],

  cli: (name, domain, _blueprint) => [
    [
      'command',
      `# ${name}:command — Add a CLI Command

You are an assistant working within the **${name}** framework, a **${toTitleCase(domain)}** project.

## Your Task

Create a new CLI command that users can invoke from the terminal.

### Information to Gather

If not provided, ask for:
1. **Command name** (e.g., "init", "build", "deploy")
2. **Description** — One-line summary for the help text
3. **Arguments** — Positional arguments with types and descriptions
4. **Options/flags** — Named options with short flags, types, defaults, and descriptions
5. **Subcommands** (if any)

### Implementation Steps

1. **Create the command file:**
   - File: \`src/command/<name>.command.js\`
   - Export a command definition object with: name, description, arguments, options, and handler.
   - The handler should be an async function that receives parsed arguments and options.

2. **Implement the handler:**
   - Parse and validate all inputs.
   - Delegate business logic to the service layer — keep the command thin.
   - Use the output layer for all user-facing output (formatted text, tables, JSON).
   - Handle errors gracefully with clear, actionable error messages.

3. **Register the command:**
   - Add the command to the command registry / parser configuration.
   - Update the barrel export in \`src/command/index.js\`.

4. **Add help text:**
   - Include a detailed help string with usage synopsis, description, and examples.
   - Ensure \`--help\` works for this command.

5. **Write tests:**
   - File: \`tests/unit/<name>.command.test.js\`
   - Test: argument parsing, validation, handler execution, error cases, and output format.
   - Test both interactive and non-interactive (piped) modes if applicable.

### Coding Standards

- Commands must support \`--json\` output flag for scriptability.
- Use consistent exit codes: 0 = success, 1 = user error, 2 = system error.
- Include at least one example in the help text.
- Validate all user inputs and provide suggestions for common mistakes.
- Support \`--verbose\` and \`--quiet\` flags for output control.

### Output

After creating the files, provide:
1. Summary of all files created/modified.
2. Usage example showing the command in action.
3. Help text output.
`,
    ],
    [
      'plugin',
      `# ${name}:plugin — Add a Plugin

You are an assistant working within the **${name}** framework, a **${toTitleCase(domain)}** project.

## Your Task

Create a new plugin that extends the CLI's functionality.

### Information to Gather

If not provided, ask for:
1. **Plugin name** (e.g., "analytics", "auto-update", "theme")
2. **Purpose** — What capability the plugin adds
3. **Hook points** — Which lifecycle events it listens to (init, beforeCommand, afterCommand, etc.)
4. **Configuration** — What settings the plugin accepts

### Implementation Steps

1. **Create the plugin file:**
   - File: \`src/plugins/<name>.plugin.js\`
   - Export a plugin object with: name, version, description, and lifecycle hooks.
   - Use the standard plugin interface expected by the CLI framework.

2. **Implement lifecycle hooks:**
   - \`init(context)\` — Called when the plugin is loaded.
   - \`beforeCommand(command, args)\` — Called before any command executes.
   - \`afterCommand(command, result)\` — Called after a command completes.
   - \`teardown()\` — Called when the CLI exits.

3. **Add configuration schema:**
   - Define the configuration options the plugin accepts.
   - Provide sensible defaults for all options.
   - Validate configuration on plugin initialization.

4. **Register the plugin:**
   - Add it to the plugin registry or configuration.
   - Document how users enable/disable it.

5. **Write tests:**
   - File: \`tests/unit/<name>.plugin.test.js\`
   - Test each lifecycle hook independently.
   - Test configuration validation and defaults.
   - Test interaction with the CLI framework.

### Coding Standards

- Plugins must not modify core CLI behavior — only extend it.
- All plugin actions must be reversible in the teardown hook.
- Plugins must handle their own errors and never crash the CLI.
- Log plugin actions at the \`debug\` level.
- Include a \`version\` field for compatibility tracking.

### Output

After creating the files, provide:
1. Summary of all files created.
2. Configuration example.
3. Example showing the plugin in action.
`,
    ],
  ],

  testing: (name, domain, _blueprint) => [
    [
      'suite',
      `# ${name}:suite — Create a Test Suite

You are an assistant working within the **${name}** framework, a **${toTitleCase(domain)}** project.

## Your Task

Create a comprehensive test suite for a specific module or feature.

### Information to Gather

If not provided, ask for:
1. **Target module/feature** — What are we testing?
2. **Test type** — Unit, integration, e2e, or combination
3. **Key scenarios** — Critical paths and edge cases to cover

### Implementation Steps

1. **Analyze the target:**
   - Read the target module's source code to understand its public API.
   - Identify all exported functions, classes, and their signatures.
   - Map out dependency injection points and side effects.

2. **Create the test file:**
   - Unit: \`tests/unit/<module>.test.js\`
   - Integration: \`tests/integration/<feature>.test.js\`

3. **Structure the suite:**
   - Group tests by function or method using \`describe\` blocks.
   - Cover: happy path, edge cases, error handling, boundary values, and async behavior.
   - Use descriptive test names: "should [expected behavior] when [condition]".

4. **Set up fixtures and mocks:**
   - Create fixtures for test data in \`tests/fixtures/\` if needed.
   - Mock external dependencies at the module boundary.
   - Use setup/teardown hooks for shared state.

5. **Add coverage targets:**
   - Aim for >80% line coverage on the target module.
   - Ensure all public API paths are exercised.
   - Cover both success and failure code paths.

### Coding Standards

- One assertion per test where practical (single responsibility).
- Test behavior, not implementation details.
- Clean up side effects in afterEach/afterAll hooks.
- Use factories for test data rather than hardcoded values.
- Keep tests independent — no test should depend on another test's state.

### Output

Provide:
1. The complete test file with all test cases.
2. Any required fixture or mock files.
3. Instructions for running the new suite.
4. Coverage expectations.
`,
    ],
    [
      'mock',
      `# ${name}:mock — Create a Mock or Fixture

You are an assistant working within the **${name}** framework, a **${toTitleCase(domain)}** project.

## Your Task

Create a mock, stub, or fixture for use in the test suite.

### Information to Gather

If not provided, ask for:
1. **Target dependency** — What are we mocking? (module, API, database, service)
2. **Mock type** — Full mock, partial stub, spy, or data fixture
3. **Test context** — Which tests will use this mock?

### Implementation Steps

1. **Analyze the dependency:**
   - Read the target module to understand its interface.
   - Identify which methods and properties need to be mocked.
   - Determine if the mock needs to maintain state between calls.

2. **Create the mock/fixture:**
   - Mocks: \`tests/mocks/<dependency>.mock.js\`
   - Fixtures: \`tests/fixtures/<entity>.fixture.js\`

3. **For mocks:**
   - Implement every method from the original interface.
   - Return predictable, deterministic values.
   - Support configurable return values and error simulation.
   - Track call counts and arguments for assertion purposes.

4. **For fixtures:**
   - Create realistic but deterministic test data.
   - Use factory functions that accept overrides: \`createUser(overrides)\`.
   - Include valid and invalid data variants.
   - Generate related entities consistently (e.g., user has matching orders).

5. **Export and document:**
   - Export from the barrel file in the mocks/fixtures directory.
   - Document the mock's capabilities and limitations.
   - Provide usage examples in JSDoc comments.

### Coding Standards

- Mocks must implement the same interface as the original dependency.
- Fixtures must use factories, not static objects (prevent shared state bugs).
- Reset mock state between tests via a \`reset()\` method.
- Never mock what you do not own — wrap third-party dependencies first.
- Keep mock behavior as simple as possible; complex mocks indicate design issues.

### Output

Provide:
1. The complete mock or fixture file.
2. Usage example in a test file.
3. Documentation of available mock methods and configurable behaviors.
`,
    ],
  ],

  ui: (name, domain, _blueprint) => [
    [
      'component',
      `# ${name}:component — Create a UI Component

You are an assistant working within the **${name}** framework, a **${toTitleCase(domain)}** project.

## Your Task

Create a new reusable UI component.

### Information to Gather

If not provided, ask for:
1. **Component name** (e.g., "Button", "DataTable", "UserCard")
2. **Purpose** — What the component renders and its use case
3. **Props** — Input properties with types, defaults, and descriptions
4. **State** — Internal state the component manages
5. **Events** — Callbacks/events the component emits

### Implementation Steps

1. **Create the component file:**
   - File: \`src/components/<Name>/<Name>.js\` (or \`.jsx\`/\`.tsx\` per project convention)
   - Implement the component with clear prop types and default values.
   - Keep the component focused on a single responsibility.

2. **Add styles:**
   - File: \`src/components/<Name>/<Name>.css\` (or module/styled per convention)
   - Use the project's styling approach (CSS modules, styled-components, Tailwind, etc.).
   - Ensure responsive design and accessibility.

3. **Create the barrel export:**
   - File: \`src/components/<Name>/index.js\`
   - Re-export the component as the default and named export.

4. **Write tests:**
   - File: \`tests/unit/<Name>.test.js\`
   - Test: rendering with default props, rendering with custom props, user interactions,
     accessibility (aria attributes, keyboard navigation), and edge cases.

5. **Add to component index:**
   - Update \`src/components/index.js\` to export the new component.

### Coding Standards

- Components must be accessible: include ARIA labels, roles, and keyboard support.
- Use semantic HTML elements where possible.
- Props must have type definitions and sensible defaults.
- Avoid inline styles; use the project's styling approach.
- Keep components pure where possible; isolate side effects.
- Support both controlled and uncontrolled usage patterns.

### Output

Provide:
1. All component files (source, styles, barrel, tests).
2. Usage example with sample props.
3. Prop documentation table.
`,
    ],
    [
      'page',
      `# ${name}:page — Create a Page

You are an assistant working within the **${name}** framework, a **${toTitleCase(domain)}** project.

## Your Task

Create a new page or route in the application.

### Information to Gather

If not provided, ask for:
1. **Page name** (e.g., "Dashboard", "Settings", "UserProfile")
2. **Route path** (e.g., "/dashboard", "/settings", "/users/:id")
3. **Layout** — Which layout template to use (if applicable)
4. **Data requirements** — What data the page needs and how to fetch it
5. **Components** — Which existing components it will use

### Implementation Steps

1. **Create the page component:**
   - File: \`src/pages/<Name>/<Name>.js\`
   - Implement the page layout using existing components.
   - Add data fetching logic (API calls, state management).
   - Handle loading, error, and empty states.

2. **Register the route:**
   - Add the route to the router configuration.
   - Configure route parameters, guards, and metadata.

3. **Add page-specific styles:**
   - File: \`src/pages/<Name>/<Name>.css\`

4. **Write tests:**
   - Test: page rendering, data loading, error states, navigation, and user interactions.

5. **Update navigation:**
   - Add the page to the navigation menu or sidebar if applicable.
   - Update any breadcrumb configurations.

### Coding Standards

- Pages orchestrate components — they should not contain complex UI logic.
- Handle all async states: loading, success, error, and empty.
- Use the project's data fetching pattern (hooks, stores, services).
- Include page-level SEO metadata (title, description) if applicable.
- Implement proper loading skeletons, not just spinners.

### Output

Provide:
1. All page files (component, styles, tests).
2. Router configuration update.
3. Screenshot description of the expected layout.
`,
    ],
  ],

  'ai-agent': (name, domain, _blueprint) => [
    [
      'agent',
      `# ${name}:agent — Create an Agent

You are an assistant working within the **${name}** framework, a **${toTitleCase(domain)}** project.

## Your Task

Create a new autonomous agent definition with planning, memory, and tool-use capabilities.

### Information to Gather

If not provided, ask for:
1. **Agent name** (e.g., "ResearchAgent", "CodeReviewAgent")
2. **Purpose** — What tasks the agent performs
3. **Available tools** — Which tools the agent can use
4. **Planning strategy** — How the agent decomposes tasks (ReAct, chain-of-thought, etc.)
5. **Memory requirements** — Short-term, long-term, or both

### Implementation Steps

1. **Create the agent definition:**
   - File: \`src/agents/<name>.agent.js\`
   - Define the agent's system prompt, tool bindings, and planning strategy.
   - Configure memory providers and guardrails.

2. **Set up the planning loop:**
   - Implement the observe-think-act cycle.
   - Add step limits and timeout safeguards.
   - Include intermediate result validation.

3. **Configure tools:**
   - Bind specific tools from the tool registry.
   - Define input/output schemas for each tool call.
   - Add error recovery strategies for failed tool calls.

4. **Set up memory:**
   - Configure working memory for the current task context.
   - Configure long-term memory for cross-session learning (if needed).
   - Define memory retrieval strategies (similarity, recency, relevance).

5. **Add guardrails:**
   - Define safety boundaries for the agent's actions.
   - Configure rate limits for tool calls and LLM requests.
   - Add output validation before returning results.

6. **Write tests:**
   - Test: planning decomposition, tool selection, memory retrieval,
     guardrail enforcement, error recovery, and end-to-end task completion.

### Coding Standards

- Agents must be deterministic given the same inputs and tool responses.
- All external actions must go through the tool interface — no direct API calls.
- Guardrails must be checked before every tool invocation.
- Memory operations must be logged for observability.
- Include a \`dryRun\` mode for testing without side effects.

### Output

Provide:
1. The complete agent definition file.
2. Configuration example.
3. Usage example showing the agent completing a sample task.
4. Test file with key scenarios.
`,
    ],
    [
      'tool',
      `# ${name}:tool — Create an Agent Tool

You are an assistant working within the **${name}** framework, a **${toTitleCase(domain)}** project.

## Your Task

Create a new tool that agents can invoke to interact with external systems.

### Information to Gather

If not provided, ask for:
1. **Tool name** (e.g., "webSearch", "fileReader", "codeExecutor")
2. **Purpose** — What external action the tool performs
3. **Input schema** — Parameters the tool accepts
4. **Output schema** — What the tool returns
5. **Side effects** — What external state the tool modifies

### Implementation Steps

1. **Create the tool file:**
   - File: \`src/tools/<name>.tool.js\`
   - Export a tool definition with: name, description, inputSchema, outputSchema, and execute function.

2. **Implement the execute function:**
   - Validate all inputs against the schema.
   - Perform the external action with proper error handling.
   - Include timeouts and retries for network operations.
   - Return structured output matching the output schema.

3. **Register the tool:**
   - Add the tool to the tool registry.
   - Update the barrel export in \`src/tools/index.js\`.

4. **Add safety measures:**
   - Input sanitization to prevent injection attacks.
   - Output size limits to prevent memory issues.
   - Rate limiting for expensive operations.

5. **Write tests:**
   - Test: input validation, successful execution, error handling,
     timeout behavior, retry logic, and output formatting.
   - Mock external dependencies for unit tests.
   - Include one integration test with the real external system (marked as slow).

### Coding Standards

- Tools must be stateless — all state goes through the agent's memory.
- Input and output schemas must be fully defined (no \`any\` types).
- Error messages must be clear enough for the agent to decide on retry vs. abandon.
- Include a \`describe()\` method that returns a human-readable tool description.
- Execution must respect the configured timeout and abort gracefully.

### Output

Provide:
1. The complete tool file with schema definitions.
2. Registration code for the tool registry.
3. Usage example showing how an agent would invoke the tool.
4. Test file covering key scenarios.
`,
    ],
  ],

  automation: (name, domain, _blueprint) => [
    [
      'workflow',
      `# ${name}:workflow — Create a Workflow

You are an assistant working within the **${name}** framework, a **${toTitleCase(domain)}** project.

## Your Task

Create a new automation workflow that orchestrates a sequence of tasks.

### Information to Gather

If not provided, ask for:
1. **Workflow name** (e.g., "deployPipeline", "dataSync", "reportGenerator")
2. **Trigger** — What starts the workflow (schedule, event, manual)
3. **Steps** — Ordered list of tasks to execute
4. **Error handling** — Retry policy, fallback behavior
5. **Outputs** — What the workflow produces when complete

### Implementation Steps

1. **Create the workflow definition:**
   - File: \`src/workflows/<name>.workflow.js\`
   - Define the workflow with: name, trigger, steps, error handling, and outputs.
   - Each step should reference a task from the task registry.

2. **Implement step orchestration:**
   - Define step execution order (sequential, parallel, or conditional).
   - Pass outputs from one step as inputs to the next.
   - Add checkpoint/resume capability for long-running workflows.

3. **Configure error handling:**
   - Define retry policies per step (max retries, backoff strategy).
   - Add fallback steps for critical failures.
   - Implement dead-letter handling for permanently failed workflows.

4. **Add observability:**
   - Log step start, completion, and failure events.
   - Track workflow duration and step timing.
   - Emit events for monitoring systems.

5. **Write tests:**
   - Test: happy path execution, step failure and retry, conditional branching,
     parallel step execution, and timeout handling.

### Coding Standards

- Workflows must be idempotent — safe to re-run from any checkpoint.
- Steps must be individually testable and reusable across workflows.
- Use structured logging with correlation IDs for traceability.
- Long-running workflows must support graceful cancellation.
- Configuration must be externalized, not hardcoded in the workflow.

### Output

Provide:
1. The complete workflow definition file.
2. Any new task files required by the workflow.
3. Configuration example.
4. Test file with key scenarios.
`,
    ],
    [
      'task',
      `# ${name}:task — Create a Task

You are an assistant working within the **${name}** framework, a **${toTitleCase(domain)}** project.

## Your Task

Create a new reusable task that can be used in automation workflows.

### Information to Gather

If not provided, ask for:
1. **Task name** (e.g., "sendEmail", "transformData", "deployService")
2. **Purpose** — What the task does
3. **Inputs** — Required and optional parameters
4. **Outputs** — What the task returns on success
5. **Side effects** — External systems affected

### Implementation Steps

1. **Create the task file:**
   - File: \`src/tasks/<name>.task.js\`
   - Export a task definition with: name, description, inputSchema, outputSchema, and execute function.

2. **Implement the execute function:**
   - Validate inputs against the schema.
   - Perform the operation with proper error handling.
   - Return structured output.
   - Support dry-run mode for testing.

3. **Register the task:**
   - Add to the task registry.
   - Update barrel export in \`src/tasks/index.js\`.

4. **Write tests:**
   - Test: input validation, execution, error handling, dry-run mode, and idempotency.

### Coding Standards

- Tasks must be idempotent and safe to retry.
- All external calls must have timeouts and error handling.
- Support a \`dryRun\` option that logs what would happen without doing it.
- Include timing information in the task output.

### Output

Provide:
1. The complete task file.
2. Registration code.
3. Usage example within a workflow.
4. Test file.
`,
    ],
  ],

  data: (name, domain, _blueprint) => [
    [
      'pipeline',
      `# ${name}:pipeline — Create a Data Pipeline

You are an assistant working within the **${name}** framework, a **${toTitleCase(domain)}** project.

## Your Task

Create a new data pipeline that processes data through a series of transformations.

### Information to Gather

If not provided, ask for:
1. **Pipeline name** (e.g., "userIngestion", "reportAggregation", "logProcessing")
2. **Data source** — Where the data comes from (file, API, database, stream)
3. **Transformations** — Processing steps to apply
4. **Data sink** — Where the processed data goes
5. **Volume** — Expected data volume (affects batch vs. stream decisions)

### Implementation Steps

1. **Create the pipeline definition:**
   - File: \`src/pipelines/<name>.pipeline.js\`
   - Define: source, transforms (in order), sink, and error handling.

2. **Implement data source:**
   - Create a reader that produces data records/chunks.
   - Support backpressure for high-volume sources.
   - Handle connection errors and retries.

3. **Implement transformations:**
   - Each transform is a pure function: \`(record) => record\`.
   - Chain transforms using the pipeline composition pattern.
   - Add validation transforms for data quality checks.

4. **Implement data sink:**
   - Create a writer that consumes processed records.
   - Support batching for efficiency.
   - Handle write failures with retry and dead-letter queues.

5. **Add observability:**
   - Track records processed, transformed, filtered, and errored.
   - Log pipeline start, completion, and checkpoint events.
   - Emit metrics for monitoring dashboards.

6. **Write tests:**
   - Test each transform independently with sample data.
   - Test the full pipeline with fixture data.
   - Test error handling and recovery.
   - Test backpressure and batching behavior.

### Coding Standards

- Transforms must be pure functions with no side effects.
- Pipelines must support both batch and incremental modes.
- Include data validation at pipeline entry and exit.
- Use streaming where possible to control memory usage.
- Log data quality metrics alongside processing metrics.

### Output

Provide:
1. The complete pipeline definition.
2. Source and sink implementations.
3. Transform functions.
4. Test file with sample data fixtures.
`,
    ],
    [
      'transform',
      `# ${name}:transform — Create a Data Transform

You are an assistant working within the **${name}** framework, a **${toTitleCase(domain)}** project.

## Your Task

Create a new data transformation function for use in data pipelines.

### Information to Gather

If not provided, ask for:
1. **Transform name** (e.g., "normalizeEmail", "aggregateByDate", "filterInactive")
2. **Input schema** — Shape of incoming records
3. **Output schema** — Shape of transformed records
4. **Logic** — The transformation rules to apply

### Implementation Steps

1. **Create the transform file:**
   - File: \`src/transforms/<name>.transform.js\`
   - Export a pure function: \`(record, context) => transformedRecord\`.
   - Include input and output schema definitions.

2. **Implement the transform:**
   - Validate the input record against the schema.
   - Apply the transformation logic.
   - Return the transformed record matching the output schema.
   - Handle null/undefined fields gracefully.

3. **Register the transform:**
   - Add to the transform registry.
   - Update barrel export in \`src/transforms/index.js\`.

4. **Write tests:**
   - Test with valid records, invalid records, edge cases (nulls, empty strings,
     extreme values), and large datasets for performance.

### Coding Standards

- Transforms MUST be pure functions — no side effects, no external state.
- Transforms must never throw — return error records or filter them out.
- Include performance benchmarks for transforms processing >10k records.
- Document the transform's data contract (input/output schemas).

### Output

Provide:
1. The complete transform file.
2. Schema definitions.
3. Test file with comprehensive edge cases.
4. Usage example in a pipeline.
`,
    ],
  ],

  plugin: (name, domain, _blueprint) => [
    [
      'extension',
      `# ${name}:extension — Create an Extension Module

You are an assistant working within the **${name}** framework, a **${toTitleCase(domain)}** project.

## Your Task

Create a new extension module that adds functionality to the framework.

### Information to Gather

If not provided, ask for:
1. **Extension name** (e.g., "caching", "metrics", "auth")
2. **Purpose** — What capability the extension adds
3. **Extension points** — Which framework hooks it uses
4. **Public API** — What the extension exposes to consumers
5. **Dependencies** — What the extension needs from the framework core

### Implementation Steps

1. **Create the extension file:**
   - File: \`src/extensions/<name>.extension.js\`
   - Export an extension definition with: name, version, hooks, and public API.

2. **Implement lifecycle hooks:**
   - \`register(framework)\` — Called when the extension is loaded.
   - \`initialize(config)\` — Called during framework initialization.
   - \`destroy()\` — Called during framework shutdown.

3. **Define the public API:**
   - Export functions and classes that consumers can use.
   - Keep the API surface small and well-documented.

4. **Add configuration:**
   - Define the extension's configuration schema.
   - Provide defaults for all configuration values.
   - Validate configuration on initialization.

5. **Write tests:**
   - Test lifecycle hooks, public API, configuration, and integration with the framework.

### Coding Standards

- Extensions must not modify framework internals — use public hooks only.
- All public API methods must have JSDoc documentation.
- Extensions must clean up after themselves in the \`destroy\` hook.
- Support lazy initialization to avoid slowing down framework startup.

### Output

Provide:
1. The complete extension file.
2. Configuration documentation.
3. Public API reference.
4. Test file.
`,
    ],
    [
      'hook',
      `# ${name}:hook — Create a Lifecycle Hook

You are an assistant working within the **${name}** framework, a **${toTitleCase(domain)}** project.

## Your Task

Create a new lifecycle hook that extensions and plugins can subscribe to.

### Information to Gather

If not provided, ask for:
1. **Hook name** (e.g., "beforeInit", "afterRequest", "onError")
2. **Trigger point** — When in the lifecycle this hook fires
3. **Payload** — What data is passed to hook handlers
4. **Return value** — Whether handlers can modify the pipeline (tapable vs. event)

### Implementation Steps

1. **Create the hook file:**
   - File: \`src/hooks/<name>.hook.js\`
   - Define the hook with: name, description, payload schema, and handler type.

2. **Implement the hook mechanism:**
   - Support synchronous and asynchronous handlers.
   - Define execution order (first-in-first-out, waterfall, parallel).
   - Allow handlers to short-circuit the pipeline if needed.

3. **Register the hook:**
   - Add to the hook registry.
   - Update the barrel export in \`src/hooks/index.js\`.

4. **Write tests:**
   - Test handler registration, execution order, async handlers,
     error handling, and short-circuit behavior.

### Coding Standards

- Hooks must have a well-defined payload schema.
- Error in one handler must not prevent others from executing (unless designed to short-circuit).
- Include timing information for performance monitoring.
- Document when the hook fires and what handlers can do with the payload.

### Output

Provide:
1. The complete hook file.
2. Registration and subscription examples.
3. Test file.
`,
    ],
  ],
};

// ---------------------------------------------------------------------------
// CommandGenerator class
// ---------------------------------------------------------------------------

/**
 * Generates Claude Code slash command files (.claude/commands/*.md) for
 * frameworks produced by ClawOS.
 *
 * Each command file is a comprehensive Markdown prompt (20-50+ lines) that
 * guides Claude through a domain-specific workflow such as creating endpoints,
 * adding tests, scaffolding components, or managing data pipelines.
 */
class CommandGenerator {
  // -----------------------------------------------------------------------
  // Public API
  // -----------------------------------------------------------------------

  /**
   * Generate all appropriate slash command files for a framework.
   *
   * Creates the output directory (if writing to disk) and generates:
   * - Base commands (help, status, test) for every framework
   * - Domain-specific commands based on the framework's domain
   *
   * @param {RequirementsProfile} profile    - The original requirements profile.
   * @param {Blueprint}           blueprint  - The composed architecture blueprint.
   * @param {string}              outputPath - Directory path where command files will be written.
   *                                           Pass an empty string to generate in-memory only.
   * @returns {Promise<GeneratedCommand[]>} Array of all generated command metadata.
   */
  async generate(profile, blueprint, outputPath) {
    if (!profile || !profile.name) {
      throw new Error('CommandGenerator.generate: profile.name is required');
    }
    if (!blueprint || !blueprint.archetype) {
      throw new Error('CommandGenerator.generate: blueprint.archetype is required');
    }

    const prefix = toCommandPrefix(profile.name);
    const domain = (blueprint.domain || blueprint.archetype).toLowerCase();

    /** @type {GeneratedCommand[]} */
    const commands = [];

    // Ensure output directory exists (if writing to disk)
    if (outputPath) {
      await fs.mkdir(outputPath, { recursive: true });
    }

    // --- Base commands (always generated) ---
    commands.push(
      await this.generateCommand(
        `${prefix}:help`,
        helpCommandContent(prefix, domain, blueprint),
        outputPath,
      ),
    );
    commands.push(
      await this.generateCommand(
        `${prefix}:status`,
        statusCommandContent(prefix, domain, blueprint),
        outputPath,
      ),
    );
    commands.push(
      await this.generateCommand(
        `${prefix}:test`,
        testCommandContent(prefix, domain, blueprint),
        outputPath,
      ),
    );

    // --- Domain-specific commands ---
    const domainCommands = this.getCommandsForDomain(domain);

    for (const [suffix, content] of domainCommands(prefix, domain, blueprint)) {
      commands.push(
        await this.generateCommand(`${prefix}:${suffix}`, content, outputPath),
      );
    }

    return commands;
  }

  /**
   * Generate a single command file.
   *
   * If outputPath is provided and non-empty, the command is written to disk.
   * The command is always returned as a {@link GeneratedCommand} object.
   *
   * @param {string} name       - Full command name (e.g., "myapp:help").
   * @param {string} content    - Markdown content of the command prompt.
   * @param {string} outputPath - Directory path for the output file (empty = in-memory only).
   * @returns {Promise<GeneratedCommand>}
   */
  async generateCommand(name, content, outputPath) {
    const filename = name.replace(/:/g, '-') + '.md';
    const fullPath = outputPath ? path.join(outputPath, filename) : '';

    if (outputPath) {
      await fs.writeFile(fullPath, content, 'utf-8');
    }

    return {
      name,
      filename,
      content,
      outputPath: fullPath,
    };
  }

  /**
   * Get the domain-specific command factory function for a given domain.
   *
   * Returns a function that, when called with (prefix, domain, blueprint),
   * produces an array of [suffix, content] pairs for each domain command.
   *
   * @param {string} domain - The framework domain (api, cli, ui, etc.).
   * @returns {(prefix: string, domain: string, blueprint: Blueprint) => [string, string][]}
   */
  getCommandsForDomain(domain) {
    const normalizedDomain = domain.toLowerCase().replace(/\s+/g, '-');
    const factory = DOMAIN_COMMAND_FACTORIES[normalizedDomain];

    if (factory) {
      return factory;
    }

    // Fallback: return an empty command set for unknown domains
    return () => [];
  }
}

// ---------------------------------------------------------------------------
// Exports
// ---------------------------------------------------------------------------

export { CommandGenerator, DOMAIN_COMMAND_FACTORIES };
export default CommandGenerator;
